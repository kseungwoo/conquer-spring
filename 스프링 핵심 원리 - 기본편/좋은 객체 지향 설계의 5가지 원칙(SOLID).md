> 인프런에서 김영한님의 [스프링 핵심 원리 - 기본편](https://www.inflearn.com/course/%EC%8A%A4%ED%94%84%EB%A7%81-%ED%95%B5%EC%8B%AC-%EC%9B%90%EB%A6%AC-%EA%B8%B0%EB%B3%B8%ED%8E%B8)을 듣고 정리하였습니다.



안녕하세요. 오늘은 좋은 객체 지향 설계를 위한 5가지 원칙, SOLID에 대해서 알아보겠습니다.



# SOLID란

SOLID는 클린코드로 유명한 로버트 마틴이라는 분이 좋은 객체 지향 설계의 5가지 원칙을 정리하면서 만들어졌습니다.

- SRP: 단일 책임 원칙(Single Responsibility Principle)
- OCP: 개방-폐쇄 원칙(Open/Closed Principle)
- LSP: 리스코프 치환 원칙(Liskov Substitution Principle)
- ISP: 인터페이스 분리 원칙 (Interface Segregation Principle)
- DIP: 의존관계 역전 원칙 (Dependency Inversion Principle)

이제 하나씩 차근차근 알아가봅시다.



# SRP 단일 책임 원칙

한 클래스는 하나의 책임만 가져야 한다는 원칙입니다. 그런데 여기서 하나의 책임이라는 것이 참 추상적입니다. 책임이 클 수도 있고, 작을 수도 있거든요. 따라서 문맥과 상황에 따라서 다릅니다. 그렇다면 단일 책임을 잘 지켰다는 것을 어떤 기준으로 판단할 수 있을까요?

여기서 중요한 판단의 기준은 변경입니다. 변경이 있을 때 파급 효과가 적으면 단일 책임 원칙을 잘 따른 것이라 볼 수 있습니다. 



# OCP 개방-폐쇄 원칙

소프트웨어 요소는 확장에는 열려있으나 변경에는 닫혀 있어야 한다는 원칙입니다. 기존 코드를 변경하지 않고 확장이 가능하다는 말인데, 머릿 속에 한 가지 떠오르는 용어가 있지 않으신가요? 바로 다형성입니다. 이전에 배웠듯이 다형성을 활용한다면 인터페이스를 구현한 새로운 클래스를 하나 만들어서 새로운 기능을 구현할 수 있죠. 역할과 구현의 분리를 통해 이뤄낼 수 있습니다.



# LSP 리스코프 치환 원칙

이 원칙은 단순히 컴파일에 성공하는 것을 넘어서, 인터페이스를 구현한 구현체는 반드시 규약을 지켜야 한다는 의미를 담고 있습니다. 예를 들어, 자동차라는 인터페이스를 구현한 구현체를 만든다면, 악셀을 밟으면 앞으로 나가도록 규약을 지켜야 합니다. 악셀을 밟았는데 뒤로 나간다면, 컴파일은 성공하겠지만 이러한 구현체는 믿고 쓸 수 없습니다.

따라서, 프로그램의 객체는 프로그램의 정확성을 깨뜨리지 않으면서 하위 타입의 인스턴스로 바꿀 수 있어야 합니다.



# ISP 인터페이스 분리 원칙

특정 클라이언트를 위한 인터페이스 여러 개가 범용 인터페이스보다 낫다는 원칙입니다. 예를 들면, 자동차 인터페이스는 운전 인터페이스, 정비 인터페이스로 나눌 수 있겠고, 사용자 클라이언트 인터페이스는 운전자 클라이언트, 정비사 클라이언트 인터페이스로 나눌 수 있습니다. 이렇게 분리한다면 정비 인터페이스 자체가 변해도 운전자 클라이언트에 영향을 주지 않습니다. 인터페이스가 명확해지고, 대체 가능성이 높아집니다.



# DIP 의존관계 역전 원칙

프로그래머는 추상화에 의존해야지, 구체화에 의존하면 안된다는 원칙입니다. 쉽게 풀어 설명하자면 구현 클래스에 의존하지 말고, 인터페이스에 의존하라는 뜻입니다. 역할에 의존하게 해야 한다는 점에서 OCP와 비슷합니다. 인터페이스에 의존해야 유연하게 구현체를 변경할 수 있습니다. 구현체에 의존하면 변경이 어려워집니다.



# 스프링이 없던 시절에는

개발자가 좋은 객체 지향 개발을 하기 위해 OCP, DIP를 지키려면, 할일이 많았습니다. 배보다 배꼽이 더 큰 상황이죠. 이러한 작업을 대신 해주는 프레임워크를 설계하고자 했습니다. 그것이 스프링 프레임워크입니다.

순수하게 자바로 OCP, DIP 원칙을 지키면서 개발을 하다보면 결국 스프링 프레임워크를 만드는 방향으로 흘러가게 됩니다.



# 좋은 객체 지향 설계를 위한 스프링의 지원

스프링은 다음 기술로 다형성과 OCP, DIP를 가능하게 지원합니다.

- DI
- DI 컨테이너 제공

이를 통해 클라이언트 코드의 변경 없이 기능을 확장할 수 있습니다.



# 역할과 구현의 분리는 반드시?

역할과 구현의 분리를 모든 설계에 적용하는 것이 아무래도 가장 이상적인 설계이겠죠. 하지만 현실적으로 인터페이슬르 도입하면 추상화라는 비용이 발생합니다. 기능을 확장할 가능성이 없다면 구체 클래스를 직접 사용하고 꼭 필요할 때 리팩터링해서 인터페이스를 도입하는 것도 방법입니다. 이것을 잘하는 것이 좋은 개발자가 하는 일입니다.

